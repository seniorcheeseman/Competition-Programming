package uvaProblems;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

public class Uva10061 {
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner in = new Scanner(System.in);
		sieve(10000000);
		while(in.hasNext())
		{
			int dec = in.nextInt();
			int unbase = in.nextInt();
			long zero =Integer.MAX_VALUE;
			int base = unbase;
			for(long i = 2;i <= base;i++)
			{
				if(base%i!=0) continue;
				
				long b=0,n=0;
				while(base%i==0 && base!=0){b++;base/=i;}
				for(long j = i;j<=dec;j*=i) n+=dec/j;
				if(zero>n/b) zero=n/b;
			}
			double digits = 0;
			for(int x=2;x<=dec;x++)
			{
				digits+= Math.log(x);
			}
			digits =digits/Math.log(unbase)+1;
			long res = (long) digits;
			System.out.println(zero + " "+ res);
			
		}
	}
	static int _sieve_size;
	static  boolean[] bs;   // 10^7 should be enough for most cases
	static  List<Integer> primes = new ArrayList<Integer>();   // compact list of primes in form of vector<int>

	static void sieve(int upperbound) {          // create list of primes in [0..upperbound]
	    _sieve_size = upperbound + 1;                   // add 1 to include upperbound
	    bs = new boolean[_sieve_size];
	    Arrays.fill(bs,true);                                    // set all bits to 1
	    bs[0] = bs[1] = false;                                     // except index 0 and 1
	    for (long i = 2; i < _sieve_size; i++) if (bs[(int)i]) {
	      // cross out multiples of i starting from i * i!
	      for (long j = i * i; j < _sieve_size; j += i) bs[(int)j] = false;
	      primes.add((int)i);  // also add this vector containing list of primes
	  } }
	static List<Integer> primeFactors(long N) {   // remember: vi is vector of integers, long is long long
	    List<Integer> factors = new ArrayList<Integer>();  // vi `primes' (generated by sieve) is optional
	    int PF_idx = 0;
	    long PF = primes.get(PF_idx);     // using PF = 2, 3, 4, ..., is also ok
	    while (N != 1 && (PF * PF <= N)) {   // stop at sqrt(N), but N can get smaller
	      while (N % PF == 0) { N /= PF; factors.add((int)PF); }    // remove this PF
	      PF = primes.get(++PF_idx);                              // only consider primes!
	    }
	    if (N != 1) factors.add((int)N);     // special case if N is actually a prime
	    return factors;         // if pf exceeds 32-bit integer, you have to change vi
	  }
}
