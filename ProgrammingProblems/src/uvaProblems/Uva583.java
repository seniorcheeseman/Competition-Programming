package uvaProblems;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

public class Uva583 {
	static	int _sieve_size;
	  static boolean[] bs;   // 10^7 should be enough for most cases
	  static List<Integer> primes = new ArrayList<Integer>();   
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner in = new Scanner(System.in);
		sieve(10000000);
        while(true)
        {
        	int next = in.nextInt();
        	if(next==0)break;
        	boolean negative = false;
        	if(next<0)negative = true;
        	List<Integer> factors = primeFactors((long)((negative)?next*-1:next));
        	String res = Integer.toString(next) +" = ";
        	if(negative)
        		{
        		res += "-1 x "+Integer.toString(factors.get(0));
        		
        		}
        	else
        	{
        		res += Integer.toString(factors.get(0));
        	}
        	for(int x=1;x<factors.size();x++)
        	{
        		res+= " x " + Integer.toString(factors.get(x));
        	}
        	System.out.println(res);
        }
	}
	static void sieve(int upperbound) {          // create list of primes in [0..upperbound]
	    _sieve_size = upperbound + 1;                   // add 1 to include upperbound
	    bs = new boolean[_sieve_size];
	    Arrays.fill(bs,true);                                    // set all bits to 1
	    bs[0] = bs[1] = false;                                     // except index 0 and 1
	    for (long i = 2; i < _sieve_size; i++) if (bs[(int)i]) {
	      // cross out multiples of i starting from i * i!
	      for (long j = i * i; j < _sieve_size; j += i) bs[(int)j] = false;
	      primes.add((int)i);  // also add this vector containing list of primes
	  } }             
	static List<Integer> primeFactors(long N) {   // remember: vi is vector of integers, long is long long
	    List<Integer> factors = new ArrayList<Integer>();  // vi `primes' (generated by sieve) is optional
	    int PF_idx = 0;
	    long PF = primes.get(PF_idx);     // using PF = 2, 3, 4, ..., is also ok
	    while (N != 1 && (PF * PF <= N)) {   // stop at sqrt(N), but N can get smaller
	      while (N % PF == 0) { N /= PF; factors.add((int)PF); }    // remove this PF
	      PF = primes.get(++PF_idx);                              // only consider primes!
	    }
	    if (N != 1) factors.add((int)N);     // special case if N is actually a prime
	    return factors;         // if pf exceeds 32-bit integer, you have to change vi
	  }

}
